<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Go Gravity: Universe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #030305;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        .btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 16px 36px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 4px;
            backdrop-filter: blur(15px);
        }
        .btn:hover { background: rgba(255, 255, 255, 0.1); border-color: white; }
        .btn:active { transform: scale(0.92); background: #ff0055; border-color: #ff0055; }
        
        #overdrive-btn {
            position: absolute;
            bottom: 20%;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 0, 85, 0.2);
            border: 4px solid #ff0055;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 12px;
            letter-spacing: 1px;
            pointer-events: auto;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 30px rgba(255, 0, 85, 0.4);
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(255, 0, 85, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 85, 0.8); }
            100% { box-shadow: 0 0 10px rgba(255, 0, 85, 0.4); }
        }

        .pause-btn {
            position: absolute;
            top: 25px;
            left: 25px;
            pointer-events: auto;
            font-size: 18px;
            padding: 10px 18px;
        }
        .score-box {
            position: absolute;
            top: env(safe-area-inset-top, 25px);
            right: 25px;
            text-align: right;
        }
        .modal {
            pointer-events: auto;
            background: rgba(5,5,7,0.98);
            border: 1px solid #222;
            padding: 50px;
            border-radius: 4px;
            text-align: center;
            box-shadow: 0 0 100px rgba(0, 0, 0, 1);
        }
        .glitch-text {
            animation: glitch 0.8s linear infinite;
            text-shadow: 3px 0 #ff0055, -3px 0 #00f2ff;
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
        #level-up-toast {
            position: absolute;
            top: 20%;
            font-size: 56px;
            font-weight: 900;
            font-style: italic;
            color: #ff0055;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            letter-spacing: -2px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="menu-screen" class="flex flex-col items-center">
            <h1 class="text-7xl font-black italic mb-2 tracking-tighter glitch-text">GO GRAVITY</h1>
            <p class="text-[10px] tracking-[0.8em] text-red-500 mb-16 font-bold text-center opacity-80">OVERDRIVE ENGINE V4</p>
            
            <button class="btn mb-5 w-80" onclick="initGame('STORY')">
                <span class="block text-xl">Enter Story</span>
                <span class="block text-[10px] opacity-50 mt-1">100 Hardened Levels</span>
            </button>
            <button class="btn mb-16 w-80" onclick="initGame('OPEN')">
                <span class="block text-xl">Open World</span>
                <span class="block text-[10px] opacity-50 mt-1">Infinite Overdrive</span>
            </button>
            
            <button class="btn w-48 opacity-30 text-[9px] py-2 border-none" onclick="toggleAudio()">SONICS: <span id="audio-status">ON</span></button>
        </div>

        <div id="level-up-toast">EVOLVING...</div>

        <!-- Overdrive Button -->
        <button id="overdrive-btn" onmousedown="handleInput(event)" ontouchstart="handleInput(event)">SYNC NOW</button>

        <!-- Pause Screen -->
        <div id="pause-screen" class="hidden modal">
            <h2 class="text-4xl font-black mb-8 italic tracking-tighter">FLOW HALTED</h2>
            <button class="btn mb-4 w-56" onclick="togglePause()">Resume</button>
            <button class="btn w-56 opacity-40 text-sm" onclick="location.reload()">Terminate</button>
        </div>

        <!-- Death/Win Screen -->
        <div id="end-screen" class="hidden modal">
            <h2 id="end-title" class="text-5xl font-black mb-4 italic tracking-tighter"></h2>
            <p id="end-msg" class="text-gray-500 mb-10 font-mono text-xs uppercase tracking-widest"></p>
            <button id="end-btn" class="btn w-56" onclick="restart()">Continue</button>
            <button class="btn mt-4 w-56 opacity-40 text-xs" onclick="location.reload()">Main Menu</button>
        </div>

        <!-- HUD -->
        <button id="pause-toggle" class="hidden btn pause-btn" onclick="togglePause()">II</button>
        <div id="hud" class="hidden score-box">
            <div id="mode-label" class="text-[10px] font-bold text-red-500 tracking-[0.3em] uppercase mb-1">STORY LVL 1</div>
            <div id="score-val" class="text-4xl font-black italic tracking-tighter">0m</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioEnabled = true;

        function playSound(freq, type, duration, vol = 0.1, slide = true) {
            if (!audioEnabled || audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(slide) osc.frequency.exponentialRampToValueAtTime(freq/2, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        const sfx = {
            jump: () => playSound(700, 'triangle', 0.1, 0.05),
            death: () => { playSound(60, 'sawtooth', 0.8, 0.2, false); playSound(40, 'square', 0.4, 0.15, true); },
            win: () => { 
                [440, 554, 659, 880].forEach((f, i) => {
                    setTimeout(() => playSound(f, 'sine', 0.2, 0.08, false), i * 60);
                });
            },
            click: () => playSound(1000, 'square', 0.03, 0.02, false),
            lvlUp: () => playSound(150, 'sawtooth', 1.0, 0.12, true),
            warp: () => playSound(900, 'sine', 0.5, 0.1, true)
        };

        function toggleAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            audioEnabled = !audioEnabled;
            document.getElementById('audio-status').innerText = audioEnabled ? 'ON' : 'OFF';
            sfx.click();
        }

        // --- Core Engine ---
        let state = 'MENU';
        let mode = 'STORY'; 
        let currentLevel = 1;
        let score = 0;
        let lastDifficultyScore = 0;
        let lastWarpScore = 0;
        let openWorldLevel = 1;
        let frameCount = 0;
        let groundY, ceilingY;
        let screenShake = 0;
        let themeColor = '#ff0055';
        let targetSpeed = 8;
        let currentSpeed = 8;
        let isMirrored = false;
        let overdriveVisible = false;

        let player = {
            x: 0, y: 0, w: 28, h: 28,
            dir: 1, vel: 0, grav: 1.4,
            trail: [],
            rotation: 0,
            targetRotation: 0,
            blur: []
        };

        let obstacles = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            groundY = canvas.height * 0.65;
            ceilingY = canvas.height * 0.35;
            player.x = canvas.width * 0.2;
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInput(e) {
            if (e) e.preventDefault();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (state === 'PLAYING') {
                // If mirrored, right becomes left (inverted logic)
                player.dir *= -1;
                player.vel = player.dir * 4;
                player.targetRotation += Math.PI;
                sfx.jump();
            }
        }

        // Global listeners
        window.addEventListener('mousedown', (e) => {
            if (e.target.id === 'overdrive-btn' || overdriveVisible === false) handleInput(e);
        });
        window.addEventListener('touchstart', (e) => {
            if (e.target.id === 'overdrive-btn' || overdriveVisible === false) handleInput(e);
        }, {passive:false});
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput();
            if (e.code === 'Escape') togglePause();
        });

        function initGame(m) {
            mode = m;
            state = 'PLAYING';
            score = 0;
            lastDifficultyScore = 0;
            lastWarpScore = 0;
            openWorldLevel = 1;
            frameCount = 0;
            isMirrored = false;
            obstacles = [];
            themeColor = '#ff0055';
            
            targetSpeed = mode === 'STORY' ? 8 + (currentLevel * 0.25) : 9;
            currentSpeed = targetSpeed;

            player.y = groundY - player.h;
            player.dir = 1;
            player.vel = 0;
            player.rotation = 0;
            player.targetRotation = 0;
            player.trail = [];
            player.blur = [];

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('pause-toggle').classList.remove('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            updateHUD();
            sfx.click();
        }

        function updateHUD() {
            const label = document.getElementById('mode-label');
            label.innerText = mode === 'STORY' ? `Sector ${currentLevel}` : `Overdrive ${openWorldLevel}`;
            label.style.color = themeColor;
        }

        function togglePause() {
            if (state === 'PLAYING') {
                state = 'PAUSED';
                document.getElementById('pause-screen').classList.remove('hidden');
            } else if (state === 'PAUSED') {
                state = 'PLAYING';
                document.getElementById('pause-screen').classList.add('hidden');
            }
            sfx.click();
        }

        function restart() {
            if (state === 'WIN') currentLevel++;
            initGame(mode);
        }

        function spawnObstacle() {
            if (overdriveVisible) return; // No spawns during overdrive moments

            if (mode === 'STORY' && score > (150 + currentLevel * 5)) {
                if (!obstacles.find(o => o.type === 'portal')) {
                    obstacles.push({ x: canvas.width + 100, y: ceilingY - 50, w: 120, h: (groundY-ceilingY)+100, type: 'portal' });
                }
                return;
            }

            const isTop = Math.random() > 0.5;
            const h = 45 + Math.random() * 40;
            
            let behavior = 'normal';
            const roll = Math.random();
            const difficultyBias = mode === 'STORY' ? (currentLevel / 100) : (openWorldLevel / 15);
            
            if (roll < Math.min(0.3 + difficultyBias, 0.85)) {
                behavior = ['jump', 'fake', 'slide', 'grow', 'shift'][Math.floor(Math.random() * 5)];
            }

            obstacles.push({
                x: canvas.width + 50,
                y: isTop ? ceilingY : groundY - h,
                w: 32, h: h,
                pos: isTop ? 'top' : 'bottom',
                behavior,
                triggered: false,
                active: true,
                type: 'spike',
                vx: 0,
                vy: 0
            });
        }

        function triggerWarp() {
            isMirrored = !isMirrored;
            sfx.warp();
            screenShake = 15;
            overdriveVisible = true;
            
            const btn = document.getElementById('overdrive-btn');
            btn.style.opacity = '1';
            btn.style.transform = 'scale(1)';

            setTimeout(() => {
                overdriveVisible = false;
                btn.style.opacity = '0';
                btn.style.transform = 'scale(0.5)';
            }, 3000);
        }

        function levelUp() {
            openWorldLevel++;
            targetSpeed += 1.2;
            sfx.lvlUp();
            const colors = ['#ff0055', '#00f2ff', '#7000ff', '#ff8800', '#00ff44', '#ffffff'];
            themeColor = colors[openWorldLevel % colors.length];
            
            const toast = document.getElementById('level-up-toast');
            toast.innerText = "OVERDRIVE " + openWorldLevel;
            toast.style.color = themeColor;
            toast.style.opacity = '1';
            toast.style.transform = 'scale(1.2) translateY(-30px)';
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'scale(1) translateY(0)';
            }, 1000);
            updateHUD();
        }

        function triggerDeath() {
            state = 'DEAD';
            sfx.death();
            screenShake = 40;
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = "SYSTEM CRASH";
            document.getElementById('end-msg').innerText = `CRITICAL FAILURE AT ${Math.floor(score)}m`;
            document.getElementById('end-btn').innerText = "Reboot";
            document.getElementById('overdrive-btn').style.opacity = '0';
        }

        function triggerWin() {
            state = 'WIN';
            sfx.win();
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = "SECTOR SYNC";
            document.getElementById('end-msg').innerText = `DATA INTEGRITY 100% | NEXT SECTOR: ${currentLevel + 1}`;
            document.getElementById('end-btn').innerText = "Advance";
            document.getElementById('overdrive-btn').style.opacity = '0';
        }

        function update() {
            if (state !== 'PLAYING') return;

            frameCount++;
            score += (currentSpeed / 50);

            // Logic every 200m
            if (score - lastWarpScore >= 200) {
                lastWarpScore = score;
                triggerWarp();
            }

            if (mode === 'OPEN' && score - lastDifficultyScore >= 100) {
                lastDifficultyScore = score;
                levelUp();
            }

            document.getElementById('score-val').innerText = `${Math.floor(score)}m`;

            currentSpeed += (targetSpeed - currentSpeed) * 0.05;

            // Physics
            player.vel += player.grav * player.dir;
            player.y += player.vel;
            player.rotation += (player.targetRotation - player.rotation) * 0.2;

            if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vel = 0; }
            if (player.y < ceilingY) { player.y = ceilingY; player.vel = 0; }

            // Visual Effects
            if (currentSpeed > 10) {
                player.blur.push({x: player.x, y: player.y, r: player.rotation, a: 0.5});
                if (player.blur.length > 5) player.blur.shift();
            } else {
                player.blur = [];
            }

            player.trail.push({x: player.x, y: player.y, r: player.rotation});
            if (player.trail.length > 15) player.trail.shift();

            let rate = Math.max(20, 45 - (currentSpeed * 0.8));
            if (frameCount % Math.floor(rate) === 0) spawnObstacle();

            obstacles.forEach((obs, i) => {
                obs.x -= (currentSpeed + obs.vx);
                if (obs.behavior === 'shift') {
                    obs.y += Math.sin(frameCount * 0.1) * 3;
                }

                if (obs.type === 'portal') {
                    if (player.x > obs.x + 50) triggerWin();
                } else {
                    const d = obs.x - player.x;
                    if (!obs.triggered && d < 220 && d > 0) {
                        obs.triggered = true;
                        if (obs.behavior === 'jump') obs.y += (obs.pos === 'bottom' ? -80 : 80);
                        if (obs.behavior === 'slide') obs.vx = 6;
                        if (obs.behavior === 'grow') { 
                            obs.h *= 2.1; if(obs.pos === 'bottom') obs.y = groundY - obs.h; 
                        }
                    }
                    if (obs.behavior === 'fake' && d < 100) obs.active = false;

                    const padding = 6;
                    if (obs.active && player.x + padding < obs.x + obs.w && player.x + player.w - padding > obs.x && 
                        player.y + padding < obs.y + obs.h && player.y + player.h - padding > obs.y) {
                        triggerDeath();
                    }
                }
                if (obs.x < -300) obstacles.splice(i, 1);
            });

            if (screenShake > 0) screenShake *= 0.92;
        }

        function draw() {
            ctx.save();
            if (screenShake > 1) {
                ctx.translate((Math.random()-0.5) * screenShake, (Math.random()-0.5) * screenShake);
            }

            // Background flicker effect if mirrored
            ctx.fillStyle = isMirrored ? '#0a0507' : '#030305';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Kinetic Background
            ctx.strokeStyle = isMirrored ? '#00f2ff' : themeColor;
            ctx.globalAlpha = 0.05;
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=150) {
                let shift = (frameCount * (currentSpeed * 0.5)) % 150;
                ctx.beginPath(); 
                ctx.moveTo(i - shift, 0); 
                ctx.lineTo(i - shift - 50, canvas.height); 
                ctx.stroke();
            }

            // Rails
            ctx.globalAlpha = 0.2;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY);
            ctx.moveTo(0, ceilingY); ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Blur Effect
            player.blur.forEach((b, i) => {
                ctx.save();
                ctx.translate(b.x + player.w/2, b.y + player.h/2);
                ctx.rotate(b.r);
                ctx.fillStyle = isMirrored ? '#00f2ff' : themeColor;
                ctx.globalAlpha = (i / player.blur.length) * 0.3;
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                ctx.restore();
            });

            // Trail
            player.trail.forEach((t, i) => {
                ctx.save();
                ctx.translate(t.x + player.w/2, t.y + player.h/2);
                ctx.rotate(t.r);
                ctx.fillStyle = isMirrored ? '#00f2ff' : themeColor;
                ctx.globalAlpha = i / 30;
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                ctx.restore();
            });

            // Obstacles
            obstacles.forEach(obs => {
                if (obs.type === 'portal') {
                    const grad = ctx.createLinearGradient(obs.x, obs.y, obs.x + obs.w, obs.y);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(0.5, 'rgba(0, 255, 136, 0.6)');
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                } else {
                    if (!obs.active) return;
                    ctx.fillStyle = obs.triggered ? (isMirrored ? '#00f2ff' : themeColor) : '#2a2a2e';
                    ctx.beginPath();
                    if (obs.pos === 'bottom') {
                        ctx.moveTo(obs.x, obs.y + obs.h); 
                        ctx.lineTo(obs.x + obs.w/2, obs.y); 
                        ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                    } else {
                        ctx.moveTo(obs.x, obs.y); 
                        ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h); 
                        ctx.lineTo(obs.x + obs.w, obs.y);
                    }
                    ctx.fill();
                }
            });

            // Player Core
            if (state !== 'DEAD' && state !== 'MENU') {
                ctx.save();
                ctx.translate(player.x + player.w/2, player.y + player.h/2);
                ctx.rotate(player.rotation);
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'white';
                ctx.fillStyle = 'white';
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#030305';
                ctx.fillRect(2, -8, 6, 6);
                ctx.fillRect(2, 2, 6, 6);
                ctx.restore();
            }

            // Overdrive Visual Warning
            if (overdriveVisible) {
                ctx.fillStyle = 'white';
                ctx.globalAlpha = Math.sin(frameCount * 0.2) * 0.1;
                ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            ctx.restore();
            requestAnimationFrame(() => { update(); draw(); });
        }

        draw();
    </script>
</body>
</html>
