<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Go Gravity: Universe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #030305;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        .btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 18px 40px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            touch-action: manipulation;
        }
        .btn:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.2); }
        
        .pause-btn {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 20px;
            pointer-events: auto;
            font-size: 16px;
            padding: 12px 20px;
            z-index: 50;
        }
        .score-box {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            right: 20px;
            text-align: right;
            z-index: 50;
        }
        .modal {
            pointer-events: auto;
            background: rgba(5,5,7,0.95);
            border: 1px solid #333;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 0 100px rgba(0, 0, 0, 0.8);
            width: 90%;
            max-width: 400px;
        }
        .glitch-text {
            animation: glitch 1s linear infinite;
            text-shadow: 2px 0 #ff0055, -2px 0 #00f2ff;
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }
        #level-up-toast {
            position: absolute;
            top: 25%;
            font-size: 42px;
            font-weight: 900;
            font-style: italic;
            color: #ff0055;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
            letter-spacing: -1px;
            text-align: center;
            width: 100%;
        }
        #mobile-hint {
            position: absolute;
            bottom: 40px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0.4;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="menu-screen" class="flex flex-col items-center">
            <h1 class="text-6xl md:text-8xl font-black italic mb-2 tracking-tighter glitch-text text-center">GO GRAVITY</h1>
            <p class="text-[9px] tracking-[0.6em] text-red-500 mb-12 font-bold text-center opacity-80 uppercase">Ultimate Mobile Edition</p>
            
            <button class="btn mb-4 w-72" onclick="initGame('STORY')">
                <span class="block text-xl">Story Mode</span>
                <span class="block text-[10px] opacity-60 mt-1">Conquer the Sectors</span>
            </button>
            <button class="btn mb-12 w-72" onclick="initGame('OPEN')">
                <span class="block text-xl">Infinite</span>
                <span class="block text-[10px] opacity-60 mt-1">Harder • Faster • Chaos</span>
            </button>
            
            <button class="btn w-40 opacity-40 text-[9px] py-2 border-none" onclick="toggleAudio()">AUDIO: <span id="audio-status">ON</span></button>
        </div>

        <div id="level-up-toast">OVERDRIVE</div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="hidden modal">
            <h2 class="text-3xl font-black mb-6 italic tracking-tighter">ENGINE IDLE</h2>
            <button class="btn mb-4 w-full" onclick="togglePause()">Resume</button>
            <button class="btn w-full opacity-50 text-xs" onclick="location.reload()">Exit to Menu</button>
        </div>

        <!-- Death/Win Screen -->
        <div id="end-screen" class="hidden modal">
            <h2 id="end-title" class="text-4xl font-black mb-2 italic tracking-tighter"></h2>
            <p id="end-msg" class="text-gray-400 mb-8 font-mono text-[10px] uppercase tracking-widest"></p>
            <button id="end-btn" class="btn w-full" onclick="restart()">Retry</button>
            <button class="btn mt-4 w-full opacity-50 text-xs" onclick="location.reload()">Main Menu</button>
        </div>

        <!-- HUD -->
        <button id="pause-toggle" class="hidden btn pause-btn" onclick="togglePause()">II</button>
        <div id="hud" class="hidden score-box">
            <div id="mode-label" class="text-[9px] font-bold text-red-500 tracking-[0.2em] uppercase mb-1">STORY LVL 1</div>
            <div id="score-val" class="text-3xl font-black italic tracking-tighter">0m</div>
        </div>

        <div id="mobile-hint" class="hidden">TAP ANYWHERE TO SHIFT</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioEnabled = true;

        function playSound(freq, type, duration, vol = 0.05, slide = true) {
            if (!audioEnabled || audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(slide) osc.frequency.exponentialRampToValueAtTime(freq/4, audioCtx.currentTime + duration);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        const sfx = {
            jump: () => playSound(600, 'triangle', 0.08, 0.03),
            death: () => { playSound(50, 'sawtooth', 0.6, 0.1, false); playSound(30, 'square', 0.3, 0.1, true); },
            win: () => { [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => playSound(f, 'sine', 0.15, 0.05, false), i * 50)); },
            click: () => playSound(800, 'sine', 0.02, 0.02, false),
            lvlUp: () => playSound(200, 'sawtooth', 0.8, 0.08, true),
            warp: () => playSound(1000, 'sine', 0.4, 0.05, true)
        };

        function toggleAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            audioEnabled = !audioEnabled;
            document.getElementById('audio-status').innerText = audioEnabled ? 'ON' : 'OFF';
            sfx.click();
        }

        let state = 'MENU';
        let mode = 'STORY'; 
        let currentLevel = 1;
        let score = 0;
        let lastDifficultyScore = 0;
        let lastWarpScore = 0;
        let openWorldLevel = 1;
        let frameCount = 0;
        let groundY, ceilingY;
        let screenShake = 0;
        let themeColor = '#ff0055';
        let targetSpeed = 8;
        let currentSpeed = 8;
        let isMirrored = false;
        let warpFlash = 0;

        let player = {
            x: 0, y: 0, w: 32, h: 32,
            dir: 1, vel: 0, grav: 1.6,
            trail: [],
            rotation: 0,
            targetRotation: 0,
            blur: []
        };

        let obstacles = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            groundY = canvas.height * 0.7;
            ceilingY = canvas.height * 0.3;
            player.x = canvas.width * 0.15;
            player.w = Math.min(32, canvas.width * 0.08);
            player.h = player.w;
        }
        window.addEventListener('resize', resize);
        resize();

        function handleInput(e) {
            if (e) {
                // Ignore clicks on UI buttons
                if (e.target.closest('.btn') && !e.target.classList.contains('pause-btn')) return;
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (state === 'PLAYING') {
                player.dir *= -1;
                player.vel = player.dir * 3; // Slight initial kick
                player.targetRotation += Math.PI;
                sfx.jump();
            }
        }

        window.addEventListener('touchstart', (e) => {
            if (state === 'PLAYING') {
                e.preventDefault();
                handleInput(e);
            }
        }, {passive: false});

        window.addEventListener('mousedown', (e) => {
            if (state === 'PLAYING') handleInput(e);
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') handleInput();
            if (e.code === 'Escape') togglePause();
        });

        function initGame(m) {
            mode = m;
            state = 'PLAYING';
            score = 0;
            lastDifficultyScore = 0;
            lastWarpScore = 0;
            openWorldLevel = 1;
            frameCount = 0;
            isMirrored = false;
            obstacles = [];
            themeColor = '#ff0055';
            
            // Harder baseline for Story and Endless
            targetSpeed = mode === 'STORY' ? 8 + (currentLevel * 0.4) : 9.5;
            currentSpeed = targetSpeed;

            player.y = groundY - player.h;
            player.dir = 1;
            player.vel = 0;
            player.rotation = 0;
            player.targetRotation = 0;
            player.trail = [];
            player.blur = [];

            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('pause-toggle').classList.remove('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            document.getElementById('mobile-hint').classList.remove('hidden');
            updateHUD();
            sfx.click();
        }

        function updateHUD() {
            const label = document.getElementById('mode-label');
            label.innerText = mode === 'STORY' ? `Sector ${currentLevel}` : `Open World LVL ${openWorldLevel}`;
            label.style.color = themeColor;
        }

        function togglePause() {
            if (state === 'PLAYING') {
                state = 'PAUSED';
                document.getElementById('pause-screen').classList.remove('hidden');
            } else if (state === 'PAUSED') {
                state = 'PLAYING';
                document.getElementById('pause-screen').classList.add('hidden');
            }
            sfx.click();
        }

        function restart() {
            if (state === 'WIN') currentLevel++;
            initGame(mode);
        }

        function spawnObstacle() {
            // End story levels after a certain distance
            if (mode === 'STORY' && score > (180 + currentLevel * 10)) {
                if (!obstacles.find(o => o.type === 'portal')) {
                    obstacles.push({ x: canvas.width + 100, y: ceilingY, w: 100, h: groundY - ceilingY, type: 'portal' });
                }
                return;
            }

            const isTop = Math.random() > 0.5;
            const h = 40 + Math.random() * 50;
            
            // Difficulty bias increases significantly with score in Endless
            const difficultyBias = mode === 'STORY' ? (currentLevel / 80) : (score / 2000);
            
            let behavior = 'normal';
            const roll = Math.random();
            
            if (roll < Math.min(0.2 + difficultyBias, 0.9)) {
                // More dangerous behaviors
                const types = ['jump', 'slide', 'grow', 'shift', 'blink'];
                behavior = types[Math.floor(Math.random() * types.length)];
            }

            obstacles.push({
                x: canvas.width + 50,
                y: isTop ? ceilingY : groundY - h,
                w: 30, h: h,
                pos: isTop ? 'top' : 'bottom',
                behavior,
                triggered: false,
                active: true,
                type: 'spike',
                vx: 0,
                pulse: 0
            });
        }

        function triggerWarp() {
            isMirrored = !isMirrored;
            sfx.warp();
            screenShake = 25;
            warpFlash = 1.0;
            
            const toast = document.getElementById('level-up-toast');
            toast.innerText = "GRAVITY SHIFT";
            toast.style.color = "#ffffff";
            toast.style.opacity = '1';
            setTimeout(() => toast.style.opacity = '0', 800);
        }

        function levelUp() {
            openWorldLevel++;
            targetSpeed += 1.5; // Significant speed jump
            sfx.lvlUp();
            const colors = ['#ff0055', '#00f2ff', '#7000ff', '#ff8800', '#00ff44', '#ffffff'];
            themeColor = colors[openWorldLevel % colors.length];
            
            const toast = document.getElementById('level-up-toast');
            toast.innerText = "ACCELERATING";
            toast.style.color = themeColor;
            toast.style.opacity = '1';
            setTimeout(() => toast.style.opacity = '0', 1000);
            updateHUD();
        }

        function triggerDeath() {
            state = 'DEAD';
            sfx.death();
            screenShake = 30;
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = "CRITICAL ERROR";
            document.getElementById('end-msg').innerText = `SYSTEM FAILED AT ${Math.floor(score)}m`;
            document.getElementById('end-btn').innerText = "Reboot";
        }

        function triggerWin() {
            state = 'WIN';
            sfx.win();
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = "SECTOR CLEAR";
            document.getElementById('end-msg').innerText = `DATA SYNCED | PROCEED TO SECTOR ${currentLevel + 1}`;
            document.getElementById('end-btn').innerText = "Next Sector";
        }

        function update() {
            if (state !== 'PLAYING') return;

            frameCount++;
            score += (currentSpeed / 40);

            // Warp Shift: No button, just pure chaos every 200m
            if (score - lastWarpScore >= 200) {
                lastWarpScore = score;
                triggerWarp();
            }

            // Scaling difficulty in Open mode
            if (mode === 'OPEN' && score - lastDifficultyScore >= 250) {
                lastDifficultyScore = score;
                levelUp();
            }

            document.getElementById('score-val').innerText = `${Math.floor(score)}m`;
            currentSpeed += (targetSpeed - currentSpeed) * 0.02;

            // Physics with snappy gravity
            player.vel += player.grav * player.dir;
            player.y += player.vel;
            player.rotation += (player.targetRotation - player.rotation) * 0.25;

            // Bounds
            if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vel = 0; }
            if (player.y < ceilingY) { player.y = ceilingY; player.vel = 0; }

            // Ghostly trails
            player.trail.push({x: player.x, y: player.y, r: player.rotation});
            if (player.trail.length > 12) player.trail.shift();

            // Obstacle spawning rate
            let spawnRate = Math.max(15, 50 - (currentSpeed * 1.5));
            if (frameCount % Math.floor(spawnRate) === 0) spawnObstacle();

            obstacles.forEach((obs, i) => {
                obs.x -= (currentSpeed + obs.vx);
                
                if (obs.behavior === 'shift') {
                    obs.y += Math.sin(frameCount * 0.15) * 4;
                }
                if (obs.behavior === 'blink') {
                    obs.active = (Math.floor(frameCount / 10) % 2 === 0);
                }

                if (obs.type === 'portal') {
                    if (player.x > obs.x) triggerWin();
                } else {
                    const d = obs.x - player.x;
                    if (!obs.triggered && d < 250 && d > 0) {
                        obs.triggered = true;
                        // Challenge mechanics
                        if (obs.behavior === 'jump') obs.y += (obs.pos === 'bottom' ? -100 : 100);
                        if (obs.behavior === 'slide') obs.vx = 8;
                        if (obs.behavior === 'grow') { 
                            obs.h *= 2.2; 
                            if(obs.pos === 'bottom') obs.y = groundY - obs.h; 
                        }
                    }

                    // Collision (Pixel perfect-ish padding)
                    const p = 6;
                    if (obs.active && 
                        player.x + p < obs.x + obs.w && player.x + player.w - p > obs.x && 
                        player.y + p < obs.y + obs.h && player.y + player.h - p > obs.y) {
                        triggerDeath();
                    }
                }
                if (obs.x < -200) obstacles.splice(i, 1);
            });

            if (screenShake > 0) screenShake *= 0.9;
            if (warpFlash > 0) warpFlash *= 0.95;
        }

        function draw() {
            ctx.save();
            if (screenShake > 0.5) {
                ctx.translate((Math.random()-0.5) * screenShake, (Math.random()-0.5) * screenShake);
            }

            // Dark void background
            ctx.fillStyle = '#030305';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Speed Lines
            ctx.strokeStyle = themeColor;
            ctx.globalAlpha = 0.08;
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=100) {
                let shift = (frameCount * (currentSpeed * 0.7)) % 100;
                ctx.beginPath(); 
                ctx.moveTo(i - shift + 100, 0); 
                ctx.lineTo(i - shift, canvas.height); 
                ctx.stroke();
            }

            // Main Rails
            ctx.globalAlpha = 0.15;
            ctx.strokeStyle = isMirrored ? '#00f2ff' : themeColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY);
            ctx.moveTo(0, ceilingY); ctx.lineTo(canvas.width, ceilingY);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Trail
            player.trail.forEach((t, i) => {
                ctx.save();
                ctx.translate(t.x + player.w/2, t.y + player.h/2);
                ctx.rotate(t.r);
                ctx.fillStyle = isMirrored ? '#00f2ff' : themeColor;
                ctx.globalAlpha = (i / player.trail.length) * 0.4;
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                ctx.restore();
            });

            // Obstacles
            obstacles.forEach(obs => {
                if (obs.type === 'portal') {
                    const grad = ctx.createLinearGradient(obs.x, obs.y, obs.x + obs.w, obs.y);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(0.5, 'rgba(0, 255, 136, 0.4)');
                    grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad;
                    ctx.fillRect(obs.x, obs.y, obs.w, obs.h);
                } else {
                    if (!obs.active) return;
                    ctx.fillStyle = obs.triggered ? (isMirrored ? '#00f2ff' : themeColor) : '#222225';
                    ctx.beginPath();
                    if (obs.pos === 'bottom') {
                        ctx.moveTo(obs.x, obs.y + obs.h); 
                        ctx.lineTo(obs.x + obs.w/2, obs.y); 
                        ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                    } else {
                        ctx.moveTo(obs.x, obs.y); 
                        ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h); 
                        ctx.lineTo(obs.x + obs.w, obs.y);
                    }
                    ctx.fill();
                }
            });

            // Player Entity
            if (state !== 'DEAD' && state !== 'MENU') {
                ctx.save();
                ctx.translate(player.x + player.w/2, player.y + player.h/2);
                ctx.rotate(player.rotation);
                
                // Outer glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'white';
                ctx.fillStyle = 'white';
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                
                // Inner Detail
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#030305';
                const eyeSize = player.w * 0.2;
                ctx.fillRect(player.w*0.1, -eyeSize*1.5, eyeSize, eyeSize);
                ctx.fillRect(player.w*0.1, eyeSize*0.5, eyeSize, eyeSize);
                ctx.restore();
            }

            // Fullscreen Warp Flash
            if (warpFlash > 0) {
                ctx.fillStyle = 'white';
                ctx.globalAlpha = warpFlash * 0.5;
                ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            ctx.restore();
            requestAnimationFrame(() => { update(); draw(); });
        }

        draw();
    </script>
</body>
</html>
