<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Go Gravity: Universe</title>
    
    <!-- PWA Manifest Inline -->
    <link rel="manifest" href="data:application/manifest+json,{'name':'Go Gravity','short_name':'GoGravity','start_url':'.','display':'standalone','background_color':'#030305','theme_color':'#ff0055'}">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }
        body {
            margin: 0;
            overflow: hidden;
            background: #030305;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: none; /* Prevents browser handling of gestures */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            height: 100vh;
            width: 100vw;
            position: fixed; /* Prevents scrolling/bounce on iOS */
        }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }
        .btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 16px 36px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        .btn:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.2); }
        
        #overdrive-btn {
            position: absolute;
            bottom: calc(15% + var(--safe-bottom));
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: rgba(255, 0, 85, 0.3);
            border: 6px solid #ff0055;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 14px;
            pointer-events: auto;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 0 40px rgba(255, 0, 85, 0.5);
            animation: pulse 1s infinite;
            z-index: 50;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 0, 85, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 50px rgba(255, 0, 85, 0.8); }
        }

        .pause-btn {
            position: absolute;
            top: var(--safe-top);
            left: 20px;
            pointer-events: auto;
            font-size: 14px;
            padding: 12px 20px;
        }
        .score-box {
            position: absolute;
            top: var(--safe-top);
            right: 20px;
            text-align: right;
        }
        .modal {
            pointer-events: auto;
            background: rgba(5,5,7,0.95);
            border: 1px solid #333;
            padding: 40px;
            width: 85%;
            max-width: 400px;
            border-radius: 12px;
            text-align: center;
        }
        .glitch-text {
            text-shadow: 2px 0 #ff0055, -2px 0 #00f2ff;
        }
        #level-up-toast {
            position: absolute;
            top: 25%;
            font-size: 40px;
            font-weight: 900;
            font-style: italic;
            color: #ff0055;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <!-- Main Menu -->
        <div id="menu-screen" class="flex flex-col items-center w-full px-6">
            <h1 class="text-5xl font-black italic mb-2 tracking-tighter glitch-text">GO GRAVITY</h1>
            <p class="text-[9px] tracking-[0.5em] text-red-500 mb-12 font-bold opacity-80 uppercase">Offline Mobile Engine V5</p>
            
            <button class="btn mb-4 w-full max-w-xs" onclick="initGame('STORY')">
                <span class="block text-lg">Story Mode</span>
            </button>
            <button class="btn mb-12 w-full max-w-xs" onclick="initGame('OPEN')">
                <span class="block text-lg">Open World</span>
            </button>
            
            <button class="btn w-40 opacity-40 text-[10px] py-2" onclick="toggleAudio()">SOUND: <span id="audio-status">ON</span></button>
        </div>

        <div id="level-up-toast">EVOLVING...</div>

        <!-- Mobile Overdrive Button -->
        <button id="overdrive-btn">SYNC</button>

        <!-- Pause Screen -->
        <div id="pause-screen" class="hidden modal">
            <h2 class="text-3xl font-black mb-6 italic">PAUSED</h2>
            <button class="btn mb-4 w-full" onclick="togglePause()">Resume</button>
            <button class="btn w-full opacity-40 text-sm" onclick="location.reload()">Exit</button>
        </div>

        <!-- End Screen -->
        <div id="end-screen" class="hidden modal">
            <h2 id="end-title" class="text-4xl font-black mb-4 italic"></h2>
            <p id="end-msg" class="text-gray-400 mb-8 font-mono text-xs uppercase tracking-widest"></p>
            <button id="end-btn" class="btn w-full mb-3" onclick="restart()">Continue</button>
            <button class="btn w-full opacity-40 text-xs" onclick="location.reload()">Quit</button>
        </div>

        <!-- HUD -->
        <button id="pause-toggle" class="hidden btn pause-btn" onclick="togglePause()">II</button>
        <div id="hud" class="hidden score-box">
            <div id="mode-label" class="text-[9px] font-bold text-red-500 tracking-widest uppercase mb-1">STORY 1</div>
            <div id="score-val" class="text-3xl font-black italic">0m</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // Service Worker for Offline
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const blob = new Blob([`
                    const CACHE_NAME = 'gogravity-v5';
                    self.addEventListener('install', e => self.skipWaiting());
                    self.addEventListener('fetch', e => e.respondWith(fetch(e.request).catch(() => caches.match(e.request))));
                `], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                navigator.serviceWorker.register(url);
            });
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let audioEnabled = true;

        function playSound(freq, type, duration, vol = 0.1, slide = true) {
            if (!audioEnabled || audioCtx.state === 'suspended') return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if(slide) osc.frequency.exponentialRampToValueAtTime(freq/2, audioCtx.currentTime + duration);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch(e) {}
        }

        const sfx = {
            jump: () => playSound(600, 'triangle', 0.1, 0.04),
            death: () => playSound(50, 'sawtooth', 0.5, 0.15),
            win: () => playSound(880, 'sine', 0.3, 0.05),
            click: () => playSound(1000, 'square', 0.02, 0.02),
            warp: () => playSound(200, 'sine', 0.6, 0.1)
        };

        function toggleAudio() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            audioEnabled = !audioEnabled;
            document.getElementById('audio-status').innerText = audioEnabled ? 'ON' : 'OFF';
            sfx.click();
        }

        let state = 'MENU';
        let mode = 'STORY'; 
        let currentLevel = 1;
        let score = 0;
        let lastWarpScore = 0;
        let frameCount = 0;
        let groundY, ceilingY;
        let themeColor = '#ff0055';
        let targetSpeed = 7;
        let currentSpeed = 7;
        let isMirrored = false;
        let overdriveVisible = false;

        let player = {
            x: 0, y: 0, w: 26, h: 26,
            dir: 1, vel: 0, grav: 1.3,
            trail: [], rotation: 0, targetRotation: 0
        };

        let obstacles = [];

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            groundY = canvas.height * 0.65;
            ceilingY = canvas.height * 0.35;
            player.x = canvas.width * 0.15;
            if (state === 'MENU') {
                player.y = groundY - player.h;
            }
        }
        window.addEventListener('resize', resize);
        window.addEventListener('orientationchange', () => setTimeout(resize, 100));
        resize();

        function handleInput(e) {
            if (e) {
                if (e.cancelable) e.preventDefault();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            if (state === 'PLAYING') {
                // Logic: If overdrive button is visible, only it or specific tap works
                if (overdriveVisible && e && e.target.id !== 'overdrive-btn') return;

                player.dir *= -1;
                player.vel = player.dir * 4.5;
                player.targetRotation += Math.PI;
                sfx.jump();
            }
        }

        // Improved Mobile Input Handling
        const overdriveBtn = document.getElementById('overdrive-btn');
        overdriveBtn.addEventListener('touchstart', handleInput, { passive: false });
        overdriveBtn.addEventListener('mousedown', handleInput);

        window.addEventListener('touchstart', (e) => {
            if (e.target.id !== 'overdrive-btn') handleInput(e);
        }, { passive: false });
        window.addEventListener('mousedown', (e) => {
            if (e.target.id !== 'overdrive-btn') handleInput(e);
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput();
            if (e.code === 'Escape') togglePause();
        });

        function initGame(m) {
            mode = m;
            state = 'PLAYING';
            score = 0;
            lastWarpScore = 0;
            frameCount = 0;
            isMirrored = false;
            obstacles = [];
            themeColor = '#ff0055';
            targetSpeed = 7 + (currentLevel * 0.2);
            currentSpeed = targetSpeed;
            player.y = groundY - player.h;
            player.dir = 1;
            player.vel = 0;
            player.rotation = 0;
            player.targetRotation = 0;
            player.trail = [];
            
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('pause-toggle').classList.remove('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            document.getElementById('mode-label').innerText = `SECTOR ${currentLevel}`;
            sfx.click();
        }

        function triggerWarp() {
            isMirrored = !isMirrored;
            sfx.warp();
            overdriveVisible = true;
            overdriveBtn.style.opacity = '1';
            overdriveBtn.style.transform = 'scale(1)';

            setTimeout(() => {
                overdriveVisible = false;
                overdriveBtn.style.opacity = '0';
                overdriveBtn.style.transform = 'scale(0.5)';
            }, 3000);
        }

        function togglePause() {
            if (state === 'PLAYING') state = 'PAUSED';
            else if (state === 'PAUSED') state = 'PLAYING';
            document.getElementById('pause-screen').classList.toggle('hidden', state !== 'PAUSED');
            sfx.click();
        }

        function restart() {
            if (state === 'WIN') currentLevel++;
            initGame(mode);
        }

        function spawnObstacle() {
            if (overdriveVisible) return;
            const isTop = Math.random() > 0.5;
            const h = 40 + Math.random() * 40;
            obstacles.push({
                x: canvas.width + 50,
                y: isTop ? ceilingY : groundY - h,
                w: 30, h: h,
                pos: isTop ? 'top' : 'bottom',
                active: true
            });
        }

        function triggerDeath() {
            state = 'DEAD';
            sfx.death();
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-title').innerText = "CRASHED";
            document.getElementById('end-msg').innerText = `LOST AT ${Math.floor(score)}m`;
            document.getElementById('end-btn').innerText = "Retry";
            overdriveBtn.style.opacity = '0';
        }

        function update() {
            if (state !== 'PLAYING') return;

            frameCount++;
            score += (currentSpeed / 60);
            if (score - lastWarpScore >= 200) {
                lastWarpScore = score;
                triggerWarp();
            }

            document.getElementById('score-val').innerText = `${Math.floor(score)}m`;
            currentSpeed += (targetSpeed - currentSpeed) * 0.02;

            player.vel += player.grav * player.dir;
            player.y += player.vel;
            player.rotation += (player.targetRotation - player.rotation) * 0.2;

            if (player.y + player.h > groundY) { player.y = groundY - player.h; player.vel = 0; }
            if (player.y < ceilingY) { player.y = ceilingY; player.vel = 0; }

            player.trail.push({x: player.x, y: player.y, r: player.rotation});
            if (player.trail.length > 12) player.trail.shift();

            let spawnRate = Math.max(25, 50 - (currentSpeed * 1.5));
            if (frameCount % Math.floor(spawnRate) === 0) spawnObstacle();

            obstacles.forEach((obs, i) => {
                obs.x -= currentSpeed;
                const p = 6; // Padding
                if (obs.active && player.x + p < obs.x + obs.w && player.x + player.w - p > obs.x && 
                    player.y + p < obs.y + obs.h && player.y + player.h - p > obs.y) {
                    triggerDeath();
                }
                if (obs.x < -100) obstacles.splice(i, 1);
            });
        }

        function draw() {
            ctx.fillStyle = isMirrored ? '#0a0507' : '#030305';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Grid Lines
            ctx.strokeStyle = isMirrored ? '#00f2ff' : themeColor;
            ctx.globalAlpha = 0.1;
            ctx.lineWidth = 1;
            for(let i=0; i<canvas.width; i+=100) {
                let s = (frameCount * 2) % 100;
                ctx.beginPath(); ctx.moveTo(i-s, 0); ctx.lineTo(i-s, canvas.height); ctx.stroke();
            }

            // Rails
            ctx.globalAlpha = 0.3;
            ctx.strokeRect(0, ceilingY, canvas.width, 1);
            ctx.strokeRect(0, groundY, canvas.width, 1);

            // Player Trail
            player.trail.forEach((t, i) => {
                ctx.save();
                ctx.translate(t.x + player.w/2, t.y + player.h/2);
                ctx.rotate(t.r);
                ctx.fillStyle = isMirrored ? '#00f2ff' : themeColor;
                ctx.globalAlpha = i / 25;
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                ctx.restore();
            });

            // Spikes
            ctx.globalAlpha = 1;
            obstacles.forEach(obs => {
                ctx.fillStyle = isMirrored ? '#00f2ff' : themeColor;
                ctx.beginPath();
                if (obs.pos === 'bottom') {
                    ctx.moveTo(obs.x, obs.y + obs.h); ctx.lineTo(obs.x + obs.w/2, obs.y); ctx.lineTo(obs.x + obs.w, obs.y + obs.h);
                } else {
                    ctx.moveTo(obs.x, obs.y); ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h); ctx.lineTo(obs.x + obs.w, obs.y);
                }
                ctx.fill();
            });

            // Player
            if (state !== 'DEAD' && state !== 'MENU') {
                ctx.save();
                ctx.translate(player.x + player.w/2, player.y + player.h/2);
                ctx.rotate(player.rotation);
                ctx.fillStyle = 'white';
                ctx.shadowBlur = 15;
                ctx.shadowColor = 'white';
                ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
                ctx.restore();
            }

            // Flash Screen for Overdrive
            if (overdriveVisible) {
                ctx.fillStyle = 'white';
                ctx.globalAlpha = Math.sin(frameCount * 0.1) * 0.05;
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }

            requestAnimationFrame(() => { update(); draw(); });
        }
        draw();
    </script>
</body>
</html>
